1. Komunikacja synchroniczna to nie to samo co programowanie synchroniczne.

Flow synchroniczne z aplikacji

Actor ---> /inquiries/submit ---> Translations (traslate inquiry) ---> Tickets (create ticket) ---> Actor

2. Fallacies of distributed computing

3. Jakie s¹ problemy z synchronicznym flow?
- opóŸnienia na poszczególnych callach spowalnia ca³e flow. Czekanie do 3s jest jeszcze akceptowalne
- b³êdy na poszczególnych etapach powoduj¹, ¿e dane s¹ niespójne, ca³y Use Case nie dzia³a, a wiadomoœæ przepada
- niedostêpnoœæ jednej us³ugi w ³añcuchu powoduje, ¿e Use Case nie dzia³a, a wiadomoœæ przepada
- miêdzy us³ugami jest ciasne powi¹zanie (coupling), bo trzeba wiedzieæ jakie us³ugi i w jakiej kolejnoœci odpytywaæ.
- hardcodowane adresy i porty uniemo¿liwiaj¹ skalowanie

4. Komunikacja Asynchroniczna
- dobr¹ analogi¹ jest poczta
- nie wymaga dostêpnoœci ani gotowoœci odbiorcy, ¿eby siê powiod³a.
- istnieje poœrednik, o którym wiedz¹ nadawcy i odbiorcy
	Zalety:
	- wystarczy znaæ jeden adres, prostsza konfiguracja
	Wady:
	- single point of failure, jak siê wy³o¿y, to game over
	- mo¿e siê przytykaæ przy du¿ym obci¹¿eniu, wiêc system bêdzie wolny

Scenariusze komunikacji:
1 - 1 -> Direct (bezpoœrednia)
1 - n -> Pub-Sub, odbiorcy oczekuj¹ swojej kopii komunikatu

Do rozwi¹zania wyzwañ komunikacji asynchronicznej powsta³y Message Brokery. Smart Broker, Dumb Consumer

5. Rabbit MQ i AMQP
- Rabbit jest dojrza³y, oparty na protokole AMQP
- w protokole AMQP podstawow¹ jednostk¹ danych jest ramka, jest ich 9
- AMQP to protokó³ programowalny

Bulding blocki Rabbit MQ
- po³¹czenia s¹ kosztowne, jak siê je stworzy, to trzeba je trzymaæ
- w ramach po³¹czenia jest wiele channeli (lekkich po³¹czeñ), np. jednego per handler/kolejka
- channele s¹ powo³ywane do ¿ycia, a po pracy s¹ zamykane
- producent wysy³a wiadomoœæ do Exchenga
- konsumenci pod³¹czaj¹ siê do kolejek
- binding - definicja regu³ trasowania - exchange na podstawie routingu wie, do jakiej kolejki przekazaæ wiadomoœæ
- producent i konsument nie wiedz¹ o sobie nic

Programista musi umieæ zaprojektowaæ drogê komunikatów (od producenta do konsumenta), czyli stworzyæ topologiê.

Topologia to sposób po³¹czeñ ró¿nych elementów

Porty
	- 5672:5672 = komunikacja AMQP
	- 15672:15672 - ui
	- 15692:15692 - metryki dla Prometheusa

6. Po³¹czenie

- Virtual Host

Po³¹czenie powinny byæ jedno per aplikacja, bo jest drogie.
Kana³ dzia³a w ramach jednego po³¹czenia, jest tañszy do utworzenia. 
 - powinien byæ d³ugo ¿yj¹cy
 - nie jest Thread Safe
 - daje API do komunikacji


V-Host-  sposób logicznego separowania konfiguracji w ramach jednej instajci Rabbita. Np. ka¿da aplikacja ma swój VHost, albo ka¿de œrodowisko. To co jest w VHost jest niedostêpne w innym VHost, wiêc logicznie siê separujemy od reszty.

Koperta wiadomoœci - wszystko to co jest dodatkowo przesy³ane wraz z payloadem, czyli tym faktycznym miêsem, które nas interesuje. W RabbitMQ jest X w³aœciwoœci, np. MessageId, routing, Type itd. To czego brakuje, mo¿na dodaæ do dynamicznej kolekcji nag³ówków (max 128kB). ALe np. MassTransis wszystko upycha w payloadzie i ten payload staje siê kopert¹.

Semantyka
a. Komenda - intencja zmiany stanu systemu
b. Event - informuje o zmianie stanu systemu, inni na to reaguj¹
c. Request - Response - nadawca wywo³uje komendê, ale dodatkowo otrzymuje odpowiedŸ

Jeœli by siê tak zastanowiæ, to komenda lub event implikuj¹ topologiê. Event bêdziemy wysy³aæ do wiêkszej liczby odbiorców, a command raczej do jednego.

ECST (Event carries state) vs Event Notification
ECST - wszystkie informacje zawarte w Evencie
EN - tylko niezbêdna informacja, by pobraæ sobie najnowszy stan ze Ÿród³a prawdy


MODU£ 7

¯eby wys³aæ wiadomoœæ, trzeba podaæ adres: Exchange + Routing Key. Wiadomoœci zawsze wysy³a siê na Exchange.
Exchange decyduje, na jak¹ kolejkê przekierowaæ wiadomoœæ na podstawie routing Key i nag³ówków.
Wyró¿niamy 4 typy Wymian
1. Fanout - przesy³a do wszystkich kolejek bez patrzenia na routing key. 
2. Direct - przesy³a z Exchange do konkretnej kolejki na podstawie dok³adnego dopasowania routing-key
3. Topic - przekazuje wiadomoœci na podstawie dopasowania routing.key. 
	* - dok³adnie jedno s³owo
	# - dowolna iloœæ s³ó
np. order.* -> order.creared, order.updated, ale ju¿ nie order.has.updated
np. #.deleted -> order.deleted, product.deleted, one.two.three.deleted.

4. Headers - bierze pod uwagê nag³ówki, nie patrzy w ogóle na routing-key. Definiujemy sobie dodatkowo nag³ówek x-match:[all|any]

Alternate Exchange - jest to exchange u¿ywany, gdy nie dopasowano ¿adnego adresata w danym exchangu. Jest to taki fallback.

Exchange to Exchnage - mo¿na routowaæ z exchnage do innego exchange, zamiast kolejki.

ThreadSave<T> - przechowuje kopie zmiennej dla w¹tku. Drugi w¹tek ma inn¹ instancjê.

AMQP Default - domyœlna wymiana dla utworzonych kolejek. Upraszcza topologiê, jeœli nie potrzebujemy nic nadzwyczajnego. Jeœli podczas publikowania nie podamy wymiany, to trafi wiadomoœæ na domyœln¹ wymianê.

MODU£ 8
pull vs push - modele konsumowania


pull polega na ci¹g³ym odpytywaniu Brokera, co wysyca sieæ, jest niezalecane. Jednak s¹ przypadki, gdzie mo¿e siê to przydaæ.
push polega na wypchniêciu wiadomoœci do konsumenta w momencie gdy jest wiadomoœæ

MULTIPLEKSING - przesy³anie wielu sygna³ów jednym transportem.

Client-Side Filtering? - robisz ifa po stronie konsumenta, jeœli typ message jes ok, to go ogargniasz, jeœli nie, to sciagaasz z kolejki nic nie robi¹c.

Rozdzielanie wiadomoœci 
- competing consumers - RabitMq rozdziela po równo wiadomoœci do ka¿dego konsumenta kolejki, tak jak w rozgrywce w karty.
- ¿eby ka¿da instancja dosta³a kopiê wiadomoœci, to musi byæ kolejka, np. tymczasowa, która znika, gdy instancja zostanie ubita.

Rozszerzanie dynamiczne logiki handlera:
- Pipe and filters - rejestrujemy logiki do odpalenia wiadomoœci
- decorator - opakowujemy handler w inny handler

B³êdna topologia to te same konsekwencje co b³êdna tabela lub b³êdna klasa.
Warto napisaæ tak, by topologia tworzy³a siê sama, na starcie aplikacji.

Message TTL - usuwa wiadomoœci starsze ni¿... Przydatne w wiadomoœciach
...


